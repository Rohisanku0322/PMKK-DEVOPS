// pipeline {
//     agent any
//     stages {
//         stage (" GIT CHECKOUT") {
//             steps {
//                 echo " GIT CLONE IS FINISHED"
//             }
//         }// stage1
//         stage (" Junit") {
//             steps {
//                 echo " Junit IS FINISHED"
//             }
//         }// stage2
//         stage (" Build") {
//             steps {
//                 echo " build IS FINISHED"
//             }
//         }// stage3
//     }//stages
// }//Pipeline
pipeline {
    agent any
    environment {
        DOCKER_IMAGE='java-spring'
        DOCKER_TAG='v1'
    }

    stages {
        stage('SCM CHECKOUT') {
            steps {
            git branch:"main", url:"https://github.com/vickydevo/springboot-hello.git"
            }
        }
        stage('Build Artifact') {
            steps {
                sh "mvn clean package"
            }
        }
        stage ('Docker Image') {
            steps {
                sh "docker build -t ${DOCKER_IMAGE}:${DOCKER_TAG} ."
            }
        }
        stage ('DockerHub push'){
            steps {
                withCredentials([
                    usernamePassword(
                        credentialsId: 'docker_cred',
                        usernameVariable:'DOCKER_USER',
                        passwordVariable: 'DOCKER_PASS')]) {
                            sh '''
                            echo $DOCKER_PASS | docker login -u $DOCKER_USER --password-stdin
                            docker tag ${${DOCKER_IMAGE}}:${DOCKER_TAG} $DOCKER_USER/${DOCKER_IMAGE}:${DOCKER_TAG}
                            docker push $DOCKER_USER/${DOCKER_IMAGE}:${DOCKER_TAG}
                            '''
                            
                        }
            }
        }
    }
}

---// Jenkinsfile for parameterized build
pipeline {
    agent any

    parameters {
        string(name: 'DOCKER_IMAGE', defaultValue: 'java-spring', description: 'Docker image name')
        string(name: 'DOCKER_TAG', defaultValue: 'v1', description: 'Docker image tag')
    }

    environment {
        DOCKER_IMAGE = "${params.DOCKER_IMAGE}"
        DOCKER_TAG = "${params.DOCKER_TAG}"
    }

    stages {
        stage('SCM CHECKOUT') {
            steps {
                git branch: "main", url: "https://github.com/vickydevo/springboot-hello.git"
            }
        }

        stage('Build Artifact') {
            steps {
                sh "mvn clean package"
            }
        }

        stage('Docker Build') {
            steps {
                sh "docker build -t ${DOCKER_IMAGE}:${DOCKER_TAG} ."
            }
        }

        stage('DockerHub Push') {
            steps {
                withCredentials([
                    usernamePassword(
                        credentialsId: 'docker_cred',
                        usernameVariable: 'DOCKER_USER',
                        passwordVariable: 'DOCKER_PASS'
                    )
                ]) {
                    sh '''
                    echo $DOCKER_PASS | docker login -u $DOCKER_USER --password-stdin
                    docker tag ${DOCKER_IMAGE}:${DOCKER_TAG} $DOCKER_USER/${DOCKER_IMAGE}:${DOCKER_TAG}
                    docker push $DOCKER_USER/${DOCKER_IMAGE}:${DOCKER_TAG}
                    '''
                }
            }
        }
    }
}





If you want no .env file, you can inject in-line:
stage('Docker Compose Up') {
    steps {
        sh """
        export IMAGE_NAME=${IMAGE_NAME}
        export TAG=${TAG}
        export HOST_PORT=${HOST_PORT}
        export CONTAINER_PORT=${CONTAINER_PORT}
        docker-compose down || true
        docker-compose up -d
        """
    }
}

work
// for Docker push use docker pipeline push plugin  -- WORKONIT
// stage('Docker_push') {
//     steps {
//         script {
//             // Authenticate and push using Docker Pipeline Plugin
//             docker.withRegistry('https://index.docker.io/${DOCKER_TAG}/', 'dockerhub_cred') {
//                 def dockerImage = docker.build('springboot:latest') // Build Docker image
//                 dockerImage.push('latest') // Push Docker image with 'latest' tag
//             }
//         }
//     }
// }